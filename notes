 notes


1. Write a Python program to convert JSON data to Python object. 

gggg



that pzthonhg


ffff

1. Generate a code
blablbablba 

#1
Note:
This is an independent task. That means, the "Logger" class in this task has nothing (!!!) to do with any other task of the exam!
 
Tasks to solve:
Write a simple logger class (class name: "Logger") that creates an append-only file when a new log-object is initiated.
The logger comprises:
a private entry number generator starting with 1 and increments with each new log entry
one function 'add_entry()'  to append a new log entry to the file 'log.txt' starting with the entry number at the begining.
each entry number is written with minimum 5 characters and enclosed in square brackets.
 
Two typical log entries look like:
[    1] First entry.
[    2] Second entry.
...
[  125] This is the 125th entry.
 
With this 'logger test script' you can test your Logger class: 
logger = Logger('log.txt')
logger.add_entry('First entry.')
logger.add_entry('Second entry.')
logger.add_entry('The PDS MEP is running!')
 
Important:
Copy your whole solution (with the 'logger test script') into the text box below.
Copy also the content of your generated 'log.txt' File on the end of your solution. 

#1
class Logger:
    def __init__(self, filename):
        self.filename = filename
        self.entry_number = 1  # Initial entry number

        # Create an append-only file and write the header
        with open(self.filename, 'a') as file:
            file.write("Log Entries:\n")

    def add_entry(self, message):
        # Format the entry number with a minimum of 5 characters and enclosed in square brackets
        formatted_entry = f"[{self.entry_number:5}] {message}\n"

        # Append the entry to the file
        with open(self.filename, 'a') as file:
            file.write(formatted_entry)

        # Increment the entry number for the next log entry
        self.entry_number += 1

# Logger test script
logger = Logger('log.txt')
logger.add_entry('First entry.')
logger.add_entry('Second entry.')
logger.add_entry('The PDS MEP is running!')


#2 The given 2D list contains some empty (NA = no value is available) elements. Write a function called fixMatrix(....) that locates missing elements and fills them up by linear interpolation of the previous and next (adjacent = benachbart) elements in the same row. So, if the element E22 is missing for instance, it has to be filled up using the following formula:
E22 = (E21+E23)/2
The 2D list looks like:
[[E00, E01, E02, E03],
 [E10, E11, E12, E13],
 [E20, E21, E22, E23],
 [E30, E31, E32, E33]]
  
Tasks to solve:
Program a function fixMatrix(...) with the following rules for edge conditions:
If there is no previous element (i.e. the missing element is the first of the row) use the last element of previous row. Example: E10 = (E03+E11)/2
If there is no next element (i.e. the missing element is the last of the row) use the first element of next row. Example: E23 = (E22+E30)/2
The first element (i.e. E00) and the last element (i.e. Enn) are never 'NA's. 
There are never multiple 'NA' next to each other (=nebeneinander).
 
Write the function as generic as possible and try it with the following two 2D lists:
missingEl1 = [[   1,'NA',   3,   4],
              ['NA',   6,'NA',   8],
              [   9,  10,  11,  12],
              [  13,'NA',  15,  16]]
 
missingEl2 = [[   1,'NA',   3,   4,   5],
              [  11,'NA',  13,  14,'NA'],
              [  21,  22,'NA',  24,  25],
              [  31,  32,  33,'NA',  35],
              ['NA',  42,  43,  44,  45],
              ['NA',  52,'NA',  54,  55]]
 
Some Code Hints:
def fixMatrix(matrix):
    rows = len(matrix)           # number of rows
    cols = len(matrix[0])        # number of cols
    ...
print(fixMatrix(missingEl1))
print(fixMatrix(missingEl2))
 
Important:
Copy your whole solution into the text box below.

#4 Tasks to solve: 2
Create the class MyStr which extends the built-in class str with a property wordCount that returns the word count of the string.
 
Note:
Words are separated by spaces. That means, numbers in text also count as words.
 
The following 'inheritance test script' should print the number 69 with your implementation of MyStr.
 
# 'inheritance test script': 
txt = MyStr("Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.")
print(txt.wordCount)          # prints the number 69 to console (there are 69 words in the text!)



class MyStr(str):
    @property
    def wordCount(self):
        # Split the string into words and return the count
        words = self.split()
        return len(words)

# Inheritance test script
txt = MyStr("Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.")
print(txt.wordCount)  # prints the number 69 to console (there are 69 words in the text!)
